// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package config

import (
	"sync"
)

// Ensure, that AppMock does implement App.
// If this is not the case, regenerate this file with moq.
var _ App = &AppMock{}

// AppMock is a mock implementation of App.
//
//	func TestSomethingThatUsesApp(t *testing.T) {
//
//		// make and configure a mocked App
//		mockedApp := &AppMock{
//			DeleteFunc: func(s string) error {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(s string, ifaceVal interface{}) error {
//				panic("mock out the Get method")
//			},
//			IsRegisteredFunc: func(s string) bool {
//				panic("mock out the IsRegistered method")
//			},
//			RegisterFunc: func(s string) error {
//				panic("mock out the Register method")
//			},
//			SetFunc: func(s string, ifaceVal interface{}) error {
//				panic("mock out the Set method")
//			},
//			UnRegisterFunc: func(s string) error {
//				panic("mock out the UnRegister method")
//			},
//		}
//
//		// use mockedApp in code that requires App
//		// and then make assertions.
//
//	}
type AppMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(s string) error

	// GetFunc mocks the Get method.
	GetFunc func(s string, ifaceVal interface{}) error

	// IsRegisteredFunc mocks the IsRegistered method.
	IsRegisteredFunc func(s string) bool

	// RegisterFunc mocks the Register method.
	RegisterFunc func(s string) error

	// SetFunc mocks the Set method.
	SetFunc func(s string, ifaceVal interface{}) error

	// UnRegisterFunc mocks the UnRegister method.
	UnRegisterFunc func(s string) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// S is the s argument value.
			S string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// S is the s argument value.
			S string
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
		// IsRegistered holds details about calls to the IsRegistered method.
		IsRegistered []struct {
			// S is the s argument value.
			S string
		}
		// Register holds details about calls to the Register method.
		Register []struct {
			// S is the s argument value.
			S string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// S is the s argument value.
			S string
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
		// UnRegister holds details about calls to the UnRegister method.
		UnRegister []struct {
			// S is the s argument value.
			S string
		}
	}
	lockDelete       sync.RWMutex
	lockGet          sync.RWMutex
	lockIsRegistered sync.RWMutex
	lockRegister     sync.RWMutex
	lockSet          sync.RWMutex
	lockUnRegister   sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *AppMock) Delete(s string) error {
	if mock.DeleteFunc == nil {
		panic("AppMock.DeleteFunc: method is nil but App.Delete was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(s)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedApp.DeleteCalls())
func (mock *AppMock) DeleteCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *AppMock) Get(s string, ifaceVal interface{}) error {
	if mock.GetFunc == nil {
		panic("AppMock.GetFunc: method is nil but App.Get was just called")
	}
	callInfo := struct {
		S        string
		IfaceVal interface{}
	}{
		S:        s,
		IfaceVal: ifaceVal,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(s, ifaceVal)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedApp.GetCalls())
func (mock *AppMock) GetCalls() []struct {
	S        string
	IfaceVal interface{}
} {
	var calls []struct {
		S        string
		IfaceVal interface{}
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// IsRegistered calls IsRegisteredFunc.
func (mock *AppMock) IsRegistered(s string) bool {
	if mock.IsRegisteredFunc == nil {
		panic("AppMock.IsRegisteredFunc: method is nil but App.IsRegistered was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockIsRegistered.Lock()
	mock.calls.IsRegistered = append(mock.calls.IsRegistered, callInfo)
	mock.lockIsRegistered.Unlock()
	return mock.IsRegisteredFunc(s)
}

// IsRegisteredCalls gets all the calls that were made to IsRegistered.
// Check the length with:
//
//	len(mockedApp.IsRegisteredCalls())
func (mock *AppMock) IsRegisteredCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockIsRegistered.RLock()
	calls = mock.calls.IsRegistered
	mock.lockIsRegistered.RUnlock()
	return calls
}

// Register calls RegisterFunc.
func (mock *AppMock) Register(s string) error {
	if mock.RegisterFunc == nil {
		panic("AppMock.RegisterFunc: method is nil but App.Register was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	mock.lockRegister.Unlock()
	return mock.RegisterFunc(s)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//
//	len(mockedApp.RegisterCalls())
func (mock *AppMock) RegisterCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockRegister.RLock()
	calls = mock.calls.Register
	mock.lockRegister.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *AppMock) Set(s string, ifaceVal interface{}) error {
	if mock.SetFunc == nil {
		panic("AppMock.SetFunc: method is nil but App.Set was just called")
	}
	callInfo := struct {
		S        string
		IfaceVal interface{}
	}{
		S:        s,
		IfaceVal: ifaceVal,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(s, ifaceVal)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedApp.SetCalls())
func (mock *AppMock) SetCalls() []struct {
	S        string
	IfaceVal interface{}
} {
	var calls []struct {
		S        string
		IfaceVal interface{}
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// UnRegister calls UnRegisterFunc.
func (mock *AppMock) UnRegister(s string) error {
	if mock.UnRegisterFunc == nil {
		panic("AppMock.UnRegisterFunc: method is nil but App.UnRegister was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockUnRegister.Lock()
	mock.calls.UnRegister = append(mock.calls.UnRegister, callInfo)
	mock.lockUnRegister.Unlock()
	return mock.UnRegisterFunc(s)
}

// UnRegisterCalls gets all the calls that were made to UnRegister.
// Check the length with:
//
//	len(mockedApp.UnRegisterCalls())
func (mock *AppMock) UnRegisterCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockUnRegister.RLock()
	calls = mock.calls.UnRegister
	mock.lockUnRegister.RUnlock()
	return calls
}
